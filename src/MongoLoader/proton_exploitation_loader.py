import os
import torch
from pymongo import MongoClient
from transformers import set_seed, pipeline, AutoTokenizer, AutoModelForCausalLM
from huggingface_hub import login
from datetime import datetime
from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer
from dotenv import load_dotenv

# Compatibility tier → adjective mapping
COMPAT_SCORE_DICT = {
    "borked": "horrible",
    "bronze": "bad",
    "silver": "acceptable",
    "gold": "good",
    "platinum": "excellent"
}

# Tier ↔ numeric mapping
TIER_TO_NUM = {"borked": 0, "bronze": 1, "silver": 2, "gold": 3, "platinum": 4}
NUM_TO_TIER = {v: k for k, v in TIER_TO_NUM.items()}

# Initialize sentiment analyzer
analyzer = SentimentIntensityAnalyzer()

def initialize_model():
    """Initialize the Falcon model for text generation."""
    # Authenticate using Hugging Face token
    load_dotenv()  # Load environment variables from .env file
    hf_token = os.getenv("HF_TOKEN")
    if not hf_token:
        raise RuntimeError("HF_TOKEN not set in environment")
    login(token=hf_token)

    # Load Falcon model
    model_id = "tiiuae/falcon-rw-1b"
    tokenizer = AutoTokenizer.from_pretrained(model_id)
    model = AutoModelForCausalLM.from_pretrained(model_id, torch_dtype=torch.float16).to("cuda")
    generator = pipeline("text-generation", model=model, tokenizer=tokenizer, device=0)

    # Set reproducibility
    set_seed(42)
    
    return generator

def calculate_global_score(game_data):
    """Calculate the global score based on current, trending, and historical_max ratings."""
    weights = {"current": 0.5, "trending": 0.3, "historical_max": 0.2}
    
    # Check if any tier is 'pending' or empty
    required_fields = ["protonTier", "protonTrendingTier", "protonBestReportedTier"]
    for field in required_fields:
        if not game_data.get(field) or game_data[field] == "pending":
            return None
    
    # Convert tiers to lowercase and validate
    try:
        current_tier = game_data["protonTier"].lower()
        trending_tier = game_data["protonTrendingTier"].lower()
        historical_max_tier = game_data["protonBestReportedTier"].lower()
        
        # Validate that all tiers are in our mapping
        if not all(tier in TIER_TO_NUM for tier in [current_tier, trending_tier, historical_max_tier]):
            return None
            
        weighted_score = (
            weights["current"] * TIER_TO_NUM[current_tier] +
            weights["trending"] * TIER_TO_NUM[trending_tier] +
            weights["historical_max"] * TIER_TO_NUM[historical_max_tier]
        )
        global_score_numeric = round(weighted_score)
        return NUM_TO_TIER[global_score_numeric]
    except (KeyError, AttributeError):
        return None

def generate_review(game_name, global_score, generator):
    """Generate a review for a game based on its global score."""
    prompt = (
        f"User review: My experience with the Linux compatibility of {game_name} is {COMPAT_SCORE_DICT[global_score]} because"
    )

    result = generator(
        prompt,
        max_new_tokens=80,
        temperature=0.7,
        top_k=40,
        top_p=0.9,
        repetition_penalty=1.2,
        do_sample=True,
        num_return_sequences=1,
    )

    review = result[0]['generated_text'].strip()
    print(f"Generated review for {game_name}: {review[:20]}...")
    return review

def classify_review_heuristic(review_text):
    """Classify a review based on sentiment analysis and keywords."""
    if not review_text:  # Handle empty reviews
        return "pending"
        
    sentiment = analyzer.polarity_scores(review_text)['compound']
    review_lower = review_text.lower()

    # Simple rule-based override
    if "crash" in review_lower or "doesn't launch" in review_lower:
        return "borked"
    elif sentiment > 0.8:
        return "platinum"
    elif sentiment > 0.5:
        return "gold"
    elif sentiment > 0.2:
        return "silver"
    elif sentiment > -0.1:
        return "bronze"
    else:
        return "borked"

def run():
    # Initialize the text generation model
    generator = initialize_model()

    # Connect to MongoDB instances
    trusted_client = MongoClient("mongodb://admin:password@mongo-trusted:27017/")
    trusted_db = trusted_client["trusted_zone"]
    trusted_collection = trusted_db["proton_data_trusted"]

    exploitation_client = MongoClient("mongodb://admin:password@mongo-exploitation:27017/")
    exploitation_db = exploitation_client["exploitation_zone"]
    exploitation_collection = exploitation_db["proton_data_exploitation"]

    # Get all games from trusted zone
    games = list(trusted_collection.find())
    total_games = len(games)
    print(f"Found {total_games} games in trusted zone")

    # Process each game
    enriched_games = []
    for i, game in enumerate(games, 1):
        # Calculate global score
        global_score = calculate_global_score(game)
        if global_score is None:
            # If any tier is 'pending', set generated_review to an empty string
            enriched_game = {
                **game,
                "global_score": None,
                "generated_review": "",
                "exploitation_zone_timestamp": datetime.now().isoformat()
            }
            print(f"Progress: {i}/{total_games} - Skipping {game['Name']} (no valid tier)")
        else:
            # Generate review
            review = generate_review(game["Name"], global_score, generator)
            print(f"Progress: {i}/{total_games}")
            # Create enriched game data
            enriched_game = {
                **game,
                "global_score": global_score,
                "generated_review": review,
                "exploitation_zone_timestamp": datetime.now().isoformat()
            }
        enriched_games.append(enriched_game)

    # Classify reviews
    print("\n=== Classifying Reviews ===")
    for game in enriched_games:
        if game["generated_review"]:
            game["heuristic_category"] = classify_review_heuristic(game["generated_review"])
            print(f"{game['Name']}: {game['heuristic_category']}")

    # Clear existing data and insert new enriched data
    exploitation_collection.delete_many({})
    if enriched_games:
        exploitation_collection.insert_many(enriched_games)
        print(f"\nInserted {len(enriched_games)} enriched records into exploitation zone")
    else:
        print("No games to process")

if __name__ == "__main__":
    run() 